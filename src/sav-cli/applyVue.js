import JSON5 from 'json5'
import {fileExistsAsync, writeFileAsync, mkdirAsync} from './sav/util/file.js'
import {resolve, basename, dirname} from 'path'
import {isString, convertCase, hyphenCase, prop} from 'sav-util'

const noticeString = '// @NOTICE This file is generated by sav-cli.\n\n'
const eslintQuotes = '/* eslint quotes: ["off"] */\n'
const applyTitle = '[     Vue]'

let appTemplate = `<template>
  <div id="app">
    <router-view class="view"></router-view>
  </div>
</template>
<script>
  export default {
    name: 'App',
    getters: [
    ],
    actions: [
    ]
  }
</script>
`
export async function createAppVue (dest) {
  let appVue = resolve(dest, 'App.vue')
  if (!await fileExistsAsync(appVue)) {
    console.log(`${applyTitle}[create] `, appVue)
    await writeFileAsync(appVue, appTemplate)
  } else {
    console.log(`${applyTitle}[  skip] `, appVue)
  }
}

let vueTemplate = `<template>
  <div className>
    <router-view></router-view>
  </div>
</template>
<script>
  export default {
    name: 'componentName',
    getters: [
    ],
    actions: [
    ]
  }
</script>
`
export async function saveVueRoutes (groups, dest) {
  let {content, files} = createVueRoutes(groups)
  console.log(`${applyTitle}[ensure] `, dest)
  await mkdirAsync(dest)
  
  let routes = resolve(dest, 'routes.js')
  console.log(`${applyTitle}[create] `, routes)
  await writeFileAsync(routes, `${noticeString}${eslintQuotes}${content}\n`)

  await Promise.all(files.map(async (file) => {
    file = resolve(dest, file)
    if (!await fileExistsAsync(file)) {
      let baseName = basename(file, '.vue')
      let dirName = basename(dirname(file))
      let template = vueTemplate
      if (baseName !== dirName) {
        template = vueTemplate.replace('<router-view></router-view>', baseName)
      }
      let className = hyphenCase(baseName)
      template = template.replace('className', `class="${className}"`)
        .replace('componentName', baseName)
      await mkdirAsync(dirname(file))
      console.log(`${applyTitle}[create] `, file)
      await writeFileAsync(file, template)
    } else {
      console.log(`${applyTitle}[  skip] `, file)
    }
  }))
}

export async function applyVue (groups, program) {
  await mkdirAsync(program.views)
  return Promise.all([
    createAppVue(program.views),
    saveVueRoutes(groups, program.views),
    createVueFiles(program.views)
  ])
}

/*
  [
    "component": "Account/Account",
    "path": "/account",
    "children": [
      {
        "component": "Account/AccountLogin",
        "name": "AccountLogin",
        "path": "login"
      }
    ]
  ]
 */

const caseType = 'camel'
const prefix = '/'
const vueCase = 'pascal'

function makeVueRouteUri (ref, nameUris) {
  let module = ref.props
  let moduleName = ref.name
  let relative = convertPath(module.path, caseType, moduleName)
  let routePrefix = module.prefix || ''
  if (routePrefix.length) {
    routePrefix = normalPath(routePrefix + '/')
  }
  let vueModuleRoute = {
    component: convertCase(vueCase, `${moduleName}/${moduleName}`),
    path: normalPath(prefix + routePrefix + relative),
    children: []
  }
  for (let routeName in module.routes) {
    let route = module.routes[routeName]
    if (route.vue !== false) {
      let path = convertPath(route.path, caseType, routeName)
      let vueRoute = {
        component: route.component || convertCase(vueCase, `${moduleName}/${moduleName}_${routeName}`),
        name: convertCase(vueCase, `${moduleName}_${routeName}`),
        path
      }
      nameUris[vueRoute.name] = `${ref.uri}.${routeName}`
      vueModuleRoute.children.push(vueRoute)
    }
  }
  return vueModuleRoute
}

function unique (arr) {
  return arr.filter((it, index) => arr.indexOf(it) === index)
}

// 生成Vue的路由文件
export function createVueRoutes (groups, JSON, es6 = true) {
  if (groups.vueInfo) {
    return groups.vueInfo
  }
  let comps = []
  let nameUris = {}
  let uris = groups.uris
  for (let uri in uris) {
    let ref = uris[uri]
    if (ref.isModal && uri.indexOf('page.') === 0) {
      let VueRoute = makeVueRouteUri(ref, nameUris)
      if (VueRoute) {
        comps.push(VueRoute)
      }
    }
  }
  let routes = JSON ? JSON.stringify(comps, null, 2) : JSON5.stringify(comps, null, 2)
  let components = []
  // let names = []
  let files = []
  routes = routes.replace(JSON5 ? /component:\s+"((\w+)\/(\w+))"/g
    : /"component":\s+"((\w+)\/(\w+))"/g, (_, path, dir, name) => {
    let file = `./${path}.vue`
    files.push(file)
    if (es6) {
      components.push(`import ${name} from '${file}'`)
      // names.push(name)
    } else {
      name = `require('${file}')`
    }
    let ret = `component: ${name}`
    return ret
  })
  if (es6) {
    // 去重
    files = unique(files)
    components = unique(components)
    // names = unique(names)
  }
  let arr = []
  if (es6) {
    arr = arr.concat(components).concat([''])
    // .concat(names.map((it) => `${it}.name = '${it}'`)).concat([''])
    .concat(`export default ${routes}`)
  } else {
    arr.push(`module.exports = ${routes}`)
  }
  let content = arr.join('\n')
  let vueInfo = {
    content,
    nameUris,
    // components,
    // names,
    files
  }
  prop(groups, 'vueInfo', vueInfo)
  return vueInfo
}

function convertPath (path, caseType, name) {
  if (!isString(path)) {
    path = convertCase(caseType, name)
  }
  return path
}

function normalPath (path) {
  return path.replace(/\/\//g, '/')
}

let clientEntry = `${noticeString}// 程序入口文件
// 宏定义采用注释的方式, 需要打包工具根据环境变量来匹配
// 区块宏 IS_DEV     是否开发环境
// 区块宏 IS_PROD    是否生产环境
// 区块宏 IS_MOCK    是否mock环境
// 区块宏 IS_LOCAL   是否本地环境

import {Vue, VueRouter, Flux, FluxVue} from './VueFlux.js'
import routes from './routes.js'
import App from './App.vue'
import {resolveContract} from 'sav'
// @TODO 这里替换为真正的contract
import contract from '../contract'

// 定义路由

let routerMode

// #if IS_LOCAL
routerMode = 'hash'
// #endif

if (!routerMode) {
  routerMode = 'history'
}

let router = new VueRouter(Object.assign({
  mode: routerMode,
  routes,
  linkActiveClass: 'is-active'
}))

let flux = new Flux({
// #if IS_DEV
  noProxy: true, // 开发模式下不使用Proxy方便调用dispatch
// #endif
// #if IS_MOCK
  mockState: true,
// #endif
  strict: true
})

// flux服务在这里嵌入
// flux.declare(...)

// #if IS_DEV
// 打印一下未定义schema的接口
flux.on('schemaRequired', (lists) => {
  console.warn('schemaRequired', lists)
})
// #endif

let ret = {}

export default ret

resolveContract({contract, flux, router}).then(() => {
// 或者flux服务在这里嵌入
// flux.declare(...)

  let vm = new Vue(Object.assign({vaf: new FluxVue({flux}), router}, App))
  vm.$mount('#app')
// #if IS_DEV
  Object.assign(ret, {
    router,
    vm,
    flux
  })
// #endif
})
`

let vueFlux = `${noticeString}// 全局的VUE组件需要在这里注册
// 其他需要用Vue的需要从这里引入
import VueRouter from 'vue-router'
import Vue from 'vue'
import {Flux, FluxVue} from 'sav-flux'

Vue.use(VueRouter)
Vue.use(FluxVue)

export {Vue}
export {VueRouter}
export {Flux}
export {FluxVue}
`

let buildClient = `${noticeString}// rollup-standard 编译配置文件
// 安装 npm i rollup-standalone sav vue vue-router cross-env standard-sass
// 本地环境构建 cross-env NODE_ENV=development IS_MOCK=1 IS_LOCAL=1 IS_DEV=1 rollup-cli -c views/build-client.js
// 生成环境构建 cross-env NODE_ENV=production rollup-cli -c views/build-client.js

const {executeRollup, fse, errorExit} = require('rollup-standalone')
const path = require('path')

let IS_PROD = process.env.NODE_ENV === 'production'

module.exports = executeRollup({
  cli: true,
  entry: path.resolve(__dirname, 'client-entry.js'),
  dest: 'static/js/client-entry.js',
  format: 'iife',
  moduleName: 'app',
  external: [
    'vue',
    'vue-router'
  ],
  babelOptions: true,
  vueOptions: true,
  sourceMap: !IS_PROD,
  uglifyOptions: IS_PROD,
  commonjsOptions: {
    include: [
      'node_modules/**',
      'contract/**'
    ]
  },
  resolveOptions: {
    browser: true
  },
  defines: {
    IS_MOCK: process.env.IS_MOCK,    // 是否使用MOCK数据
    IS_LOCAL: process.env.IS_LOCAL,  // 是否本地环境
    IS_DEV: !IS_PROD,                // 是否开发环境
    IS_PROD: IS_PROD                 // 是否生产环境
  },
  replaces: {
    'process.env.NODE_ENV': IS_PROD ? '"production"' : '"development"'
  }
})

fse.copy(require.resolve(IS_PROD
  ? 'vue/dist/vue.min.js' : 'vue/dist/vue.js'),
  'static/js/vue.js').catch(errorExit('can not copy vue'))

fse.copy(require.resolve(IS_PROD
  ? 'vue-router/dist/vue-router.min.js' : 'vue-router/dist/vue-router.js'),
  'static/js/vue-router.js').catch(errorExit('can not copy vue-router'))

process.on('unhandledRejection', (reason) => {
  console.error(reason)
  process.exit(1)
})
`

async function createVueFiles (dest) {
  let clientEntryFile = resolve(dest, 'client-entry.js')
  if (!await fileExistsAsync(clientEntryFile)) {
    console.log(`${applyTitle}[create] `, clientEntryFile)
    await writeFileAsync(clientEntryFile, clientEntry)
  } else {
    console.log(`${applyTitle}[  skip] `, clientEntryFile)
  }

  let vueFluxFile = resolve(dest, 'VueFlux.js')
  if (!await fileExistsAsync(vueFluxFile)) {
    console.log(`${applyTitle}[create] `, vueFluxFile)
    await writeFileAsync(vueFluxFile, vueFlux)
  } else {
    console.log(`${applyTitle}[  skip] `, vueFluxFile)
  }

  let buildClientFile = resolve(dest, 'build-client.js')
  if (!await fileExistsAsync(buildClientFile)) {
    console.log(`${applyTitle}[create] `, buildClientFile)
    await writeFileAsync(buildClientFile, buildClient)
  } else {
    console.log(`${applyTitle}[  skip] `, buildClientFile)
  }
}
